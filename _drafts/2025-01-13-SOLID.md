---
title: SOLID
date: 2025-01-13 11:24:20 +0100
categories: []
tags: []
---

SOLID 
Отчасти все принципы взаимосвязаны.
1. Single responsibilty классов о том, что не следует раздувать класс.  
Чем меньше класс тем больше возможность для повторного использования.
минус - так как вместо одного имеем  несколько штук, потребуется несколько вызовов memory allocation, что снижает производительность.
плюс - если классов несколько, следовательно  время жизни каждого из них короче, ссылка уничтожается и
объект становится валидным для   удаления из памяти, операциями GC.

Я бы добавил
 Single responsibilty методов
То же самое - чем меньше метод тем больше вероятность для повторного использования.
Хотя  обычно что естественно  сначала  пишут в одном методе, потом занимаются перестановками. Напоминает написание текстов, справок, там важно последовательность подачи информации, грубо говоря последовательность абзацев.
Методы в runtime, как правило,  небольшого размера, быстрее удаляются из стека.
Но в тоже время  для улучшения производительности используют inlining аттрибут, что приводит к внедрению кода вызываемого метода в код  вызывающего метода.
Время на вызове экономится. Дилемма-  сделать самому либо, поручить кому то, контрольно-распределительные функции требуют ресурсов.
Небольшими процедурами, легче манипулировать, замещать.  
Так как  в C# появилась недавно возможность (не знаю как давно, в общем она не была всегда)  описывать метод внутри друго метода, встречаю часто такой код
```
internal  A() {
private  B()
private C()
 } 
```
Если один internal вызывает несколько private методов,  для возможности тестирования ничего не меняется. 
Если бы они были все internal, то можно было бы тестировать каждый.

2. open /close та же логика только в отношении библиотек, функционал не должен быть раздутым.
Чем меньше библиотека, тем больше возможность для повторного использования.
использование internal методов позволяет их тестировать  из внешнего unittest проекта,
в тоже время  они закрыты от клиентов.
чем меньшее кол-во кода подтвергается изменениям тем лучше.

liskov о преемственности, стабильности новых реализаций.

Interfacе о том же , если класс реализует  нескольких интерфейсов можно предположить что у объекта  есть разные ответственности.
Меньше памяти потребляют, наверно?
A :IB, IC
ccылки на ограниченное число членов класса А.  Отработало, удалил.
IB b = A;
IC c = A;


Абстракция 
Применение Interface позволяет 
- тестировать, замещать mock объектами
- изменять версию библиотеки, без необходимости вносить изменения  в клиентский код.
Какие причины для этого могут быть
1 Обнаружаться недостатки  
2. Появится возможность  дя усовершествования -  другой код логирования, кеширования, включение  любые других побочных эффектов.
3. Изменение  конструкций, синтаксиса, использование классов с  более высокой производительностью, предложенными новыми версиями языка, runtime.
Например вместо  или наряду с String или Array использовать  StringSegment, StringValues, Segment, Pathstring, ArrayBuilderSegment<T>, record, Arraybuilder.
4.  Изобретение нового алгоритма. Для runtime - это нормально, встречал такие комментарии к коду со ссылкой на github, для прикладного программирования вряд ли.

class vs struct
- struct не поддерживают inheritance and poliformism, если больше 17 байтов фактически хранятся в динамической памяти. 
- struct  копируется медленнее, потому  что копирует значение, а не ссылку.